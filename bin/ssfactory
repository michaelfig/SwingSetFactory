#! /usr/bin/env node
const self = process.argv[1];
if (process.env.SWINGSET_WORKER) {
  const home = process.env.SWINGSET_WORKER;
  const send = (obj) => process.stdout.write(JSON.stringify(obj));
  send()
  console.log('TODO: Would run', home);
  process.exit(0);
}

console.log('Starting SwingSetFactory');
const PORT = Number(process.env.PORT) || 8000;
const child_process = require('child_process');

function frame(str) {
  // Netstrings.
  const buf = Buffer.from(`${str.length}:${str},`);
  return buf;
}

const Nat = require('@agoric/nat');
function unframe(framed, maxLength) {
  const match = framed.match(/^([^:]+):/);
  if (!match) {
    // Not yet enough data.
    return [undefined, framed];
  }
  if (match[1].test(/^(0|[1-9]\d+)$/)) {
    throw TypeError(`Invalid Netstring length code ${match[1]}`);
  }

  const length = Nat(match[1]);
  if (maxLength !== undefined && length > maxLength) {
    throw RangeError(`Netstring length exceeds ${maxLength}`);
  }

  const str = framed.slice(match[0].length);
  if (str.length < length + 1) {
    // Mark this buffer as not yet ready.
    return [undefined, framed];
  }
  if (str[length] != ',') {
    throw TypeError(`Netstring terminator missing from ${str}`);
  }
  return [str.substr(0, length - 1), str.substr(length)];
}

async function runWorker(home, send) {
  return new Promise((resolve, reject) => {
    let buf = '';
    const worker = child_process.fork(self, [], {
      env: {...process.env, SWINGSET_WORKER: home},
      silent: true,
      });
    send({type: 'WORKER_START', send: (obj) => {
      if (obj.type === 'WORKER_KILL') {
        // Kill off the worker unconditionally.
        worker.kill('KILL');
      } else {
        // Send to the worker.
        worker.stdin.write(frame(JSON.stringify(obj)));
      }
    }})
    worker.stdout.on('data', (data) => {
      const str = String(data);
      console.log('from child:', str);
      buf += str;
      let strBuf;
      while ((strBuf = unframe(buf)) && strBuf[0] !== undefined) {
        buf = strBuf[1];
        send({type: 'WORKER_MESSAGE', message: strBuf[0]});
      }
    });
    worker.stderr.on('data', (data) => {
      // Note, we have no framing, since anything could write to stderr.
      console.log('child error:', data.toString().trimRight());
      send({type: 'WORKER_ERROR', error: data.toString()});
    });
    worker.on('close', (code) => {
      console.log('child exited with code', code);
      send({type: 'WORKER_EXIT', code});
      resolve(code);
    });
  });
}

// Start a network service
const fs = require('fs');
const http = require('http');
const WebSocket = require('ws');

const server = http.createServer();
const wss = new WebSocket.Server({server});

function demoPath(name) {
  // Make sure they don't try to escape the demo.
  const s = String(name);
  if (!/^[a-z][-a-z0-9_]*$/i.test(s)) {
    throw RangeError(`Invalid demo name ${s}`);
  }
  return `${__dirname}/../demo/${s}`;
}

wss.on('connection', function connection(ws) {
  let lastInstance = 0;
  const cancels = {};
  const send = (obj) => ws.send(JSON.stringify(obj));
  ws.on('close', function(code, reason) {
    console.log('client closed');
    for (const cancel of Object.values(cancels)) {
      cancel();
    }
  });
  ws.on('error', function(err) {
    console.log('client error', err);
  });
  ws.on('message', function incoming(message) {
    const msg = String(message);
    console.log('from client', msg);
    const action = JSON.parse(msg);
    switch (action.type) {
    case 'SS_DEMO': {
      const instance = ++lastInstance;
      // Buffer messages until the worker starts.
      const startBuf = [];
      let toWorker = (obj) => {
        startBuf.push(obj);
      };
      function fromWorker(obj) {
        console.log('from worker', obj);
        switch (obj.type) {
          case 'WORKER_START':
            toWorker = obj.send;
            while (startBuf.length > 0) {
              // Send the buffered messages.
              toWorker(startBuf.shift());
            }
            cancels[instance] = () => {
              toWorker({type: 'WORKER_KILL'});
            };
            return;
        }
        send({type: 'SS_ERROR', instance, error: `Unrecognized worker message ${action.type}`});
      }

      runWorker(demoPath(action.name), fromWorker)
        .then((code) => {
          delete cancels[instance];
          console.log('got worker exit of', code);
          send({type: 'SS_EXIT', instance, code});
        })
        .catch(e => {
          console.log('got exception', e);
          send({type: 'SS_ERROR', instance, error})
        });
      break;
    }
    case 'SS_EXIT': {
      toWorker({type: 'WORKER_EXIT'})
    }
    case 'SS_CANCEL': {
      const cancel = cancels[instance];
      if (!cancel) {
        send({type: 'SS_ERROR', instance, error: `No cancel function for ${instance}`});
        return;
      }
      cancel();
    }
    }
    send({type: 'SS_ERROR', error: `Unrecognized client message ${action.type}`});
  });
});

server.listen(PORT, function listening() {
  console.log('Listening on', PORT);
});