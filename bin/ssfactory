#! /usr/bin/env node
const self = process.argv[1];
if (process.env.SWINGSET_WORKER) {
  const home = process.env.SWINGSET_WORKER;
  const send = (obj) => process.stdout.write(JSON.stringify(obj));
  send()
  console.log('TODO: Would run', home);
  process.exit(0);
}

console.log('Starting SwingSetFactory');
const PORT = Number(process.env.PORT) || 8000;
const child_process = require('child_process');

function frame(str) {
  // Netstrings.
  const buf = Buffer.from(`${str.length}:${str},`);
  return buf;
}

const Nat = require('@agoric/nat');
function unframe(framed, maxLength) {
  const match = framed.match(/^([^:]+):/);
  if (!match) {
    // Not yet enough data.
    return [undefined, framed];
  }
  if (match[1].test(/^(0|[1-9]\d+)$/)) {
    throw TypeError(`Invalid Netstring length code ${match[1]}`);
  }

  const length = Nat(match[1]);
  if (maxLength !== undefined && length > maxLength) {
    throw RangeError(`Netstring length exceeds ${maxLength}`);
  }

  const str = framed.slice(match[0].length);
  if (str.length < length + 1) {
    // Mark this buffer as not yet ready.
    return [undefined, framed];
  }
  if (str[length] != ',') {
    throw TypeError(`Netstring terminator missing from ${str}`);
  }
  return [str.substr(0, length - 1), str.substr(length)];
}

let lastWorkerID = 0;
async function runWorker(instance, home, send) {
  const workerID = ++lastWorkerID;
  const log = (...args) => console.log(`Worker.${workerID}[${instance}]:`, ...args)
  return new Promise((resolve, reject) => {
    let buf = '';
    const worker = child_process.fork(self, [], {
      env: {...process.env, SWINGSET_WORKER: home},
      silent: true,
      });
    send({type: 'WORKER_START', send: (obj) => {
      if (obj.type === 'WORKER_KILL') {
        // Kill off the worker unconditionally.
        worker.kill('KILL');
      } else {
        // Send to the worker.
        worker.stdin.write(frame(JSON.stringify(obj)));
      }
    }})
    worker.stdout.on('data', (data) => {
      const str = String(data);
      log('from child:', str);
      buf += str;
      let strBuf;
      while ((strBuf = unframe(buf)) && strBuf[0] !== undefined) {
        buf = strBuf[1];
        send({type: 'WORKER_MESSAGE', message: strBuf[0]});
      }
    });
    worker.stderr.on('data', (data) => {
      // Note, we have no framing, since anything could write to stderr.
      log('child error:', data.toString().trimRight());
      send({type: 'WORKER_ERROR', error: data.toString()});
    });
    worker.on('close', (code) => {
      log('child exited with code', code);
      send({type: 'WORKER_EXIT', code});
      resolve(code);
    });
  });
}

// Start a network service
const fs = require('fs');
const express = require('express');
const WebSocket = require('ws');

const app = express();
const server = app.listen(PORT, function listening() {
  console.log('Listening on', PORT);
});
const wss = new WebSocket.Server({server});

app.use(express.static(`${__dirname}/../ui/build`));

function newVatMachineID() {
  return `FIXME:${Math.random()}`;
}

function demoPath(name) {
  // Make sure they don't try to escape the demo.
  const s = String(name);
  if (!/^[a-z][-a-z0-9_]*$/i.test(s)) {
    throw RangeError(`Invalid demo name ${s}`);
  }
  return `${__dirname}/../demo/${s}`;
}

let lastClientID = 0;
wss.on('connection', function connection(ws, req) {
  const cancels = {};
  const fwd = req.headers['x-forwarded-for'];
  const ip = fwd ? fwd.split(/\s*,\s*/)[0] : req.connection.remoteAddress;
  const clientID = `${++lastClientID}`;
  const log = (...args) => console.log(`Client.${clientID}[${ip}]:`, ...args);
  const send = (obj) => ws.send(JSON.stringify(obj));
  log('Connected');
  ws.on('close', function(code, reason) {
    log('client closed');
    for (const [instance, cancel] of Object.entries(cancels)) {
      try {
        cancel();
      } catch (e) {
        log(`Cannot cancel ${instance}`, e);
      }
    }
  });
  ws.on('error', function(err) {
    log('client error', err);
  });
  ws.on('message', function incoming(message) {
    try {
      const msg = String(message);
      log('from client', msg);
      const action = JSON.parse(msg);
      switch (action.type) {
      case 'SS_DEMO': {
        const instance = newVatMachineID();
        const log = (...args) => console.log(`Client.${clientID}[${ip}][${instance}]:`, ...args);
        // Buffer messages until the worker starts.
        const startBuf = [];
        let toWorker = (obj) => {
          startBuf.push(obj);
        };
        function fromWorker(obj) {
          try {
            log('from worker', obj);
            switch (obj.type) {
              case 'WORKER_START':
                toWorker = obj.send;
                while (startBuf.length > 0) {
                  // Send the buffered messages.
                  toWorker(startBuf.shift());
                }
                cancels[instance] = () => {
                  toWorker({type: 'WORKER_KILL'});
                };
                return;
            }
            send({type: 'SS_ERROR', instance, error: `Unrecognized worker message type ${JSON.stringify(action.type)}`});
          } catch (e) {
            log(`Internal ${instance} error`, e);
            send({type: 'SS_ERROR', instance, error: `Internal error processing worker message`});
          }
        }

        runWorker(instance, demoPath(action.name), fromWorker)
          .then((code) => {
            delete cancels[instance];
            log('got worker exit of', code);
            send({type: 'SS_EXIT', instance, code});
          })
          .catch(e => {
            log('got exception', e);
            send({type: 'SS_ERROR', instance, error})
          });
        break;
      }
      case 'SS_EXIT': {
        toWorker({type: 'WORKER_EXIT'})
      }
      case 'SS_CANCEL': {
        const cancel = cancels[instance];
        if (!cancel) {
          send({type: 'SS_ERROR', instance, error: `No cancel function for ${instance}`});
          return;
        }
        cancel();
      }
      }
      send({type: 'SS_ERROR', error: `Unrecognized client message ${action.type}`});
    } catch (e) {
      log(`Error processing message ${JSON.stringify(message)}`, e);
      send({type: 'SS_ERROR', error: `Internal server error`});
    }
  });
});
